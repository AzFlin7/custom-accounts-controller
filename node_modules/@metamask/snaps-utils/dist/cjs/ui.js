"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    validateTextLinks: function() {
        return validateTextLinks;
    },
    validateComponentLinks: function() {
        return validateComponentLinks;
    }
});
const _snapssdk = require("@metamask/snaps-sdk");
const _utils = require("@metamask/utils");
const MARKDOWN_LINK_REGEX = RegExp("\\[(?<name>[^\\]]*)\\]\\((?<url>[^)]+)\\)", "giu");
const ALLOWED_PROTOCOLS = [
    'https:',
    'mailto:'
];
function validateTextLinks(text, isOnPhishingList) {
    const matches = String.prototype.matchAll.call(text, MARKDOWN_LINK_REGEX);
    for (const { groups } of matches){
        const link = groups?.url;
        /* This case should never happen with the regex but the TS type allows for undefined */ /* istanbul ignore next */ if (!link) {
            continue;
        }
        try {
            const url = new URL(link);
            (0, _utils.assert)(ALLOWED_PROTOCOLS.includes(url.protocol), `Protocol must be one of: ${ALLOWED_PROTOCOLS.join(', ')}.`);
            const hostname = url.protocol === 'mailto:' ? url.pathname.split('@')[1] : url.hostname;
            (0, _utils.assert)(!isOnPhishingList(hostname), 'The specified URL is not allowed.');
        } catch (error) {
            throw new Error(`Invalid URL: ${error instanceof _utils.AssertionError ? error.message : 'Unable to parse URL.'}`);
        }
    }
}
function validateComponentLinks(component, isOnPhishingList) {
    const { type } = component;
    if (type === _snapssdk.NodeType.Panel) {
        component.children.forEach((node)=>validateComponentLinks(node, isOnPhishingList));
    }
    if (type === _snapssdk.NodeType.Text) {
        validateTextLinks(component.value, isOnPhishingList);
    }
}

//# sourceMappingURL=ui.js.map