{"version":3,"sources":["../../src/structs.ts"],"sourcesContent":["import { isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport { resolve } from 'path';\nimport type { Failure } from 'superstruct';\nimport { Struct, StructError, create, string, coerce } from 'superstruct';\nimport type { AnyStruct } from 'superstruct/dist/utils';\n\nimport { indent } from './strings';\n\n/**\n * Infer a struct type, only if it matches the specified type. This is useful\n * for defining types and structs that are related to each other in separate\n * files.\n *\n * @example\n * ```typescript\n * // In file A\n * export type GetFileArgs = {\n *   path: string;\n *   encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n * };\n *\n * // In file B\n * export const GetFileArgsStruct = object(...);\n *\n * // If the type and struct are in the same file, this will return the type.\n * // Otherwise, it will return `never`.\n * export type GetFileArgs =\n *   InferMatching<typeof GetFileArgsStruct, GetFileArgs>;\n * ```\n */\nexport type InferMatching<\n  StructType extends Struct<any, any>,\n  Type,\n> = StructType['TYPE'] extends Type ? Type : never;\n\n/**\n * A wrapper of `superstruct`'s `string` struct that coerces a value to a string\n * and resolves it relative to the current working directory. This is useful\n * for specifying file paths in a configuration file, as it allows the user to\n * use both relative and absolute paths.\n *\n * @returns The `superstruct` struct, which validates that the value is a\n * string, and resolves it relative to the current working directory.\n * @example\n * ```ts\n * const config = struct({\n *   file: file(),\n *   // ...\n * });\n *\n * const value = create({ file: 'path/to/file' }, config);\n * console.log(value.file); // /process/cwd/path/to/file\n * ```\n */\nexport function file() {\n  return coerce(string(), string(), (value) => {\n    return resolve(process.cwd(), value);\n  });\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(struct, [\n      ...failures(),\n    ])}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(struct, prefix, suffix, error, () =>\n    arrayToGenerator(error.failures()),\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => green(type));\n  }\n\n  return null;\n}\n\n/**\n * Get a error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${bold(failure.path.join('.'))} — `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n) {\n  const received = red(JSON.stringify(failure.value));\n  const prefix = getStructErrorPrefix(failure);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(/the literal `(.+)`,/u, `the value to be \\`${green('$1')}\\`,`)\n      .replace(/, but received: (.+)/u, `, but received: ${red('$1')}`);\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${bold(\n      failure.path.join('.'),\n    )}, received: ${received}.`;\n  }\n\n  return `${prefix}Expected a value of type ${green(\n    failure.type,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(`• ${getStructFailureMessage(struct, failure)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n"],"names":["isObject","bold","green","red","resolve","Struct","StructError","create","string","coerce","indent","file","value","process","cwd","named","name","struct","type","SnapsStructError","constructor","prefix","suffix","failure","failures","message","getStructErrorMessage","arrayToGenerator","array","item","getError","error","createFromStruct","getStructFromPath","path","reduce","result","key","schema","getUnionStructNames","Array","isArray","map","getStructErrorPrefix","length","join","getStructFailureMessage","received","JSON","stringify","childStruct","unionNames","replace","formattedFailures"],"mappings":"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"}