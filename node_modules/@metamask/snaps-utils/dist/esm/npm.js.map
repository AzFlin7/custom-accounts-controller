{"version":3,"sources":["../../src/npm.ts"],"sourcesContent":["import { assertIsSnapIcon } from './icon';\nimport {\n  getValidatedLocalizationFiles,\n  validateSnapManifestLocalizations,\n} from './localization';\nimport { validateNpmSnapManifest } from './manifest/manifest';\nimport { assertIsSnapManifest } from './manifest/validation';\nimport type { SnapFiles, UnvalidatedSnapFiles } from './types';\nimport { assertIsNpmSnapPackageJson, NpmSnapFileNames } from './types';\n\nexport const EXPECTED_SNAP_FILES = [\n  'manifest',\n  'packageJson',\n  'sourceCode',\n] as const;\n\nexport const SnapFileNameFromKey = {\n  manifest: NpmSnapFileNames.Manifest,\n  packageJson: NpmSnapFileNames.PackageJson,\n  sourceCode: 'source code bundle',\n} as const;\n\n// TODO: Refactor this to be more shared with other validation.\n\n/**\n * Validates the files extracted from an npm Snap package tarball by ensuring\n * that they're non-empty and that the Json files match their respective schemas\n * and the Snaps publishing specification.\n *\n * @param snapFiles - The object containing the expected Snap file contents,\n * if any.\n * @param errorPrefix - The prefix of the error message.\n * @returns A tuple of the Snap manifest object and the Snap source code.\n */\nexport async function validateNpmSnap(\n  snapFiles: UnvalidatedSnapFiles,\n  errorPrefix?: `${string}: `,\n): Promise<SnapFiles> {\n  EXPECTED_SNAP_FILES.forEach((key) => {\n    if (!snapFiles[key]) {\n      throw new Error(\n        `${errorPrefix ?? ''}Missing file \"${SnapFileNameFromKey[key]}\".`,\n      );\n    }\n  });\n\n  // Typecast: We are assured that the required files exist if we get here.\n  const {\n    manifest,\n    packageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  } = snapFiles as SnapFiles;\n\n  try {\n    assertIsSnapManifest(manifest.result);\n  } catch (error) {\n    throw new Error(`${errorPrefix ?? ''}${error.message}`);\n  }\n  const validatedManifest = manifest;\n\n  const { iconPath } = validatedManifest.result.source.location.npm;\n  if (iconPath && !svgIcon) {\n    throw new Error(`Missing file \"${iconPath}\".`);\n  }\n\n  try {\n    assertIsNpmSnapPackageJson(packageJson.result);\n  } catch (error) {\n    throw new Error(`${errorPrefix ?? ''}${error.message}`);\n  }\n\n  const validatedPackageJson = packageJson;\n  await validateNpmSnapManifest({\n    manifest: validatedManifest,\n    packageJson: validatedPackageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  });\n\n  if (svgIcon) {\n    try {\n      assertIsSnapIcon(svgIcon);\n    } catch (error) {\n      throw new Error(`${errorPrefix ?? ''}${error.message}`);\n    }\n  }\n\n  if (localizationFiles) {\n    try {\n      // This function validates and returns the localization files. We don't\n      // use the return value here, but we do want to validate the files.\n      getValidatedLocalizationFiles(localizationFiles);\n\n      validateSnapManifestLocalizations(\n        manifest.result,\n        localizationFiles.map((file) => file.result),\n      );\n    } catch (error) {\n      throw new Error(`${errorPrefix ?? ''}${error.message}`);\n    }\n  }\n\n  return {\n    manifest: validatedManifest,\n    packageJson: validatedPackageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  };\n}\n"],"names":["assertIsSnapIcon","getValidatedLocalizationFiles","validateSnapManifestLocalizations","validateNpmSnapManifest","assertIsSnapManifest","assertIsNpmSnapPackageJson","NpmSnapFileNames","EXPECTED_SNAP_FILES","SnapFileNameFromKey","manifest","Manifest","packageJson","PackageJson","sourceCode","validateNpmSnap","snapFiles","errorPrefix","forEach","key","Error","svgIcon","auxiliaryFiles","localizationFiles","result","error","message","validatedManifest","iconPath","source","location","npm","validatedPackageJson","map","file"],"mappings":"AAAA,SAASA,gBAAgB,QAAQ,SAAS;AAC1C,SACEC,6BAA6B,EAC7BC,iCAAiC,QAC5B,iBAAiB;AACxB,SAASC,uBAAuB,QAAQ,sBAAsB;AAC9D,SAASC,oBAAoB,QAAQ,wBAAwB;AAE7D,SAASC,0BAA0B,EAAEC,gBAAgB,QAAQ,UAAU;AAEvE,OAAO,MAAMC,sBAAsB;IACjC;IACA;IACA;CACD,CAAU;AAEX,OAAO,MAAMC,sBAAsB;IACjCC,UAAUH,iBAAiBI,QAAQ;IACnCC,aAAaL,iBAAiBM,WAAW;IACzCC,YAAY;AACd,EAAW;AAEX,+DAA+D;AAE/D;;;;;;;;;CASC,GACD,OAAO,eAAeC,gBACpBC,SAA+B,EAC/BC,WAA2B;IAE3BT,oBAAoBU,OAAO,CAAC,CAACC;QAC3B,IAAI,CAACH,SAAS,CAACG,IAAI,EAAE;YACnB,MAAM,IAAIC,MACR,CAAC,EAAEH,eAAe,GAAG,cAAc,EAAER,mBAAmB,CAACU,IAAI,CAAC,EAAE,CAAC;QAErE;IACF;IAEA,yEAAyE;IACzE,MAAM,EACJT,QAAQ,EACRE,WAAW,EACXE,UAAU,EACVO,OAAO,EACPC,cAAc,EACdC,iBAAiB,EAClB,GAAGP;IAEJ,IAAI;QACFX,qBAAqBK,SAASc,MAAM;IACtC,EAAE,OAAOC,OAAO;QACd,MAAM,IAAIL,MAAM,CAAC,EAAEH,eAAe,GAAG,EAAEQ,MAAMC,OAAO,CAAC,CAAC;IACxD;IACA,MAAMC,oBAAoBjB;IAE1B,MAAM,EAAEkB,QAAQ,EAAE,GAAGD,kBAAkBH,MAAM,CAACK,MAAM,CAACC,QAAQ,CAACC,GAAG;IACjE,IAAIH,YAAY,CAACP,SAAS;QACxB,MAAM,IAAID,MAAM,CAAC,cAAc,EAAEQ,SAAS,EAAE,CAAC;IAC/C;IAEA,IAAI;QACFtB,2BAA2BM,YAAYY,MAAM;IAC/C,EAAE,OAAOC,OAAO;QACd,MAAM,IAAIL,MAAM,CAAC,EAAEH,eAAe,GAAG,EAAEQ,MAAMC,OAAO,CAAC,CAAC;IACxD;IAEA,MAAMM,uBAAuBpB;IAC7B,MAAMR,wBAAwB;QAC5BM,UAAUiB;QACVf,aAAaoB;QACblB;QACAO;QACAC;QACAC;IACF;IAEA,IAAIF,SAAS;QACX,IAAI;YACFpB,iBAAiBoB;QACnB,EAAE,OAAOI,OAAO;YACd,MAAM,IAAIL,MAAM,CAAC,EAAEH,eAAe,GAAG,EAAEQ,MAAMC,OAAO,CAAC,CAAC;QACxD;IACF;IAEA,IAAIH,mBAAmB;QACrB,IAAI;YACF,uEAAuE;YACvE,mEAAmE;YACnErB,8BAA8BqB;YAE9BpB,kCACEO,SAASc,MAAM,EACfD,kBAAkBU,GAAG,CAAC,CAACC,OAASA,KAAKV,MAAM;QAE/C,EAAE,OAAOC,OAAO;YACd,MAAM,IAAIL,MAAM,CAAC,EAAEH,eAAe,GAAG,EAAEQ,MAAMC,OAAO,CAAC,CAAC;QACxD;IACF;IAEA,OAAO;QACLhB,UAAUiB;QACVf,aAAaoB;QACblB;QACAO;QACAC;QACAC;IACF;AACF"}