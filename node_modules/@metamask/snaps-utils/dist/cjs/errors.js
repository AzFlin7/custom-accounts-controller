"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SNAP_ERROR_WRAPPER_CODE: function() {
        return SNAP_ERROR_WRAPPER_CODE;
    },
    SNAP_ERROR_WRAPPER_MESSAGE: function() {
        return SNAP_ERROR_WRAPPER_MESSAGE;
    },
    WrappedSnapError: function() {
        return WrappedSnapError;
    },
    isSnapError: function() {
        return isSnapError;
    },
    isSerializedSnapError: function() {
        return isSerializedSnapError;
    },
    isWrappedSnapError: function() {
        return isWrappedSnapError;
    },
    unwrapError: function() {
        return unwrapError;
    }
});
const _rpcerrors = require("@metamask/rpc-errors");
const _snapssdk = require("@metamask/snaps-sdk");
const _utils = require("@metamask/utils");
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
const SNAP_ERROR_WRAPPER_CODE = -31001;
const SNAP_ERROR_WRAPPER_MESSAGE = 'Wrapped Snap Error';
var _error = /*#__PURE__*/ new WeakMap(), _message = /*#__PURE__*/ new WeakMap(), _stack = /*#__PURE__*/ new WeakMap();
class WrappedSnapError extends Error {
    /**
   * The error name.
   *
   * @returns The error name.
   */ get name() {
        return 'WrappedSnapError';
    }
    /**
   * The error message.
   *
   * @returns The error message.
   */ get message() {
        return _class_private_field_get(this, _message);
    }
    /**
   * The error stack.
   *
   * @returns The error stack.
   */ get stack() {
        return _class_private_field_get(this, _stack);
    }
    /**
   * Convert the error to a JSON object.
   *
   * @returns The JSON object.
   */ toJSON() {
        const cause = isSnapError(_class_private_field_get(this, _error)) ? _class_private_field_get(this, _error).serialize() : (0, _rpcerrors.serializeCause)(_class_private_field_get(this, _error));
        return {
            code: SNAP_ERROR_WRAPPER_CODE,
            message: SNAP_ERROR_WRAPPER_MESSAGE,
            data: {
                cause
            }
        };
    }
    /**
   * Serialize the error to a JSON object. This is called by
   * `@metamask/rpc-errors` when serializing the error.
   *
   * @returns The JSON object.
   */ serialize() {
        return this.toJSON();
    }
    /**
   * Create a new `WrappedSnapError`.
   *
   * @param error - The error to create the `WrappedSnapError` from.
   */ constructor(error){
        const message = (0, _snapssdk.getErrorMessage)(error);
        super(message);
        _class_private_field_init(this, _error, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _message, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _stack, {
            writable: true,
            value: void 0
        });
        _class_private_field_set(this, _error, error);
        _class_private_field_set(this, _message, message);
        _class_private_field_set(this, _stack, (0, _snapssdk.getErrorStack)(error));
    }
}
function isSnapError(error) {
    if ((0, _utils.isObject)(error) && 'serialize' in error && typeof error.serialize === 'function') {
        const serialized = error.serialize();
        return (0, _utils.isJsonRpcError)(serialized) && isSerializedSnapError(serialized);
    }
    return false;
}
function isSerializedSnapError(error) {
    return error.code === _snapssdk.SNAP_ERROR_CODE && error.message === _snapssdk.SNAP_ERROR_MESSAGE;
}
function isWrappedSnapError(error) {
    return (0, _utils.isJsonRpcError)(error) && error.code === SNAP_ERROR_WRAPPER_CODE && error.message === SNAP_ERROR_WRAPPER_MESSAGE;
}
/**
 * Get a JSON-RPC error with the given code, message, stack, and data.
 *
 * @param code - The error code.
 * @param message - The error message.
 * @param stack - The error stack.
 * @param data - Additional data for the error.
 * @returns The JSON-RPC error.
 */ function getJsonRpcError(code, message, stack, data) {
    const error = new _rpcerrors.JsonRpcError(code, message, data);
    error.stack = stack;
    return error;
}
function unwrapError(error) {
    // This logic is a bit complicated, but it's necessary to handle all the
    // different types of errors that can be thrown by a Snap.
    // If the error is a wrapped Snap error, unwrap it.
    if (isWrappedSnapError(error)) {
        // The wrapped error can be a JSON-RPC error, or an unknown error. If it's
        // a JSON-RPC error, we can unwrap it further.
        if ((0, _utils.isJsonRpcError)(error.data.cause)) {
            // If the JSON-RPC error is a wrapped Snap error, unwrap it further.
            if (isSerializedSnapError(error.data.cause)) {
                const { code, message, stack, data } = error.data.cause.data.cause;
                return [
                    getJsonRpcError(code, message, stack, data),
                    true
                ];
            }
            // Otherwise, we use the original JSON-RPC error.
            const { code, message, stack, data } = error.data.cause;
            return [
                getJsonRpcError(code, message, stack, data),
                false
            ];
        }
        // Otherwise, we throw an internal error with the wrapped error as the
        // message.
        return [
            getJsonRpcError(_rpcerrors.errorCodes.rpc.internal, (0, _snapssdk.getErrorMessage)(error.data.cause), (0, _snapssdk.getErrorStack)(error.data.cause)),
            false
        ];
    }
    // The error can be a non-wrapped JSON-RPC error, in which case we can just
    // re-throw it with the same code, message, and data.
    if ((0, _utils.isJsonRpcError)(error)) {
        const { code, message, stack, data } = error;
        return [
            getJsonRpcError(code, message, stack, data),
            false
        ];
    }
    // If the error is not a wrapped error, we don't know how to handle it, so we
    // throw an internal error with the error as the message.
    return [
        getJsonRpcError(_rpcerrors.errorCodes.rpc.internal, (0, _snapssdk.getErrorMessage)(error), (0, _snapssdk.getErrorStack)(error)),
        false
    ];
}

//# sourceMappingURL=errors.js.map