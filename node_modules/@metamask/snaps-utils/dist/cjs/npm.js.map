{"version":3,"sources":["../../src/npm.ts"],"sourcesContent":["import { assertIsSnapIcon } from './icon';\nimport {\n  getValidatedLocalizationFiles,\n  validateSnapManifestLocalizations,\n} from './localization';\nimport { validateNpmSnapManifest } from './manifest/manifest';\nimport { assertIsSnapManifest } from './manifest/validation';\nimport type { SnapFiles, UnvalidatedSnapFiles } from './types';\nimport { assertIsNpmSnapPackageJson, NpmSnapFileNames } from './types';\n\nexport const EXPECTED_SNAP_FILES = [\n  'manifest',\n  'packageJson',\n  'sourceCode',\n] as const;\n\nexport const SnapFileNameFromKey = {\n  manifest: NpmSnapFileNames.Manifest,\n  packageJson: NpmSnapFileNames.PackageJson,\n  sourceCode: 'source code bundle',\n} as const;\n\n// TODO: Refactor this to be more shared with other validation.\n\n/**\n * Validates the files extracted from an npm Snap package tarball by ensuring\n * that they're non-empty and that the Json files match their respective schemas\n * and the Snaps publishing specification.\n *\n * @param snapFiles - The object containing the expected Snap file contents,\n * if any.\n * @param errorPrefix - The prefix of the error message.\n * @returns A tuple of the Snap manifest object and the Snap source code.\n */\nexport async function validateNpmSnap(\n  snapFiles: UnvalidatedSnapFiles,\n  errorPrefix?: `${string}: `,\n): Promise<SnapFiles> {\n  EXPECTED_SNAP_FILES.forEach((key) => {\n    if (!snapFiles[key]) {\n      throw new Error(\n        `${errorPrefix ?? ''}Missing file \"${SnapFileNameFromKey[key]}\".`,\n      );\n    }\n  });\n\n  // Typecast: We are assured that the required files exist if we get here.\n  const {\n    manifest,\n    packageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  } = snapFiles as SnapFiles;\n\n  try {\n    assertIsSnapManifest(manifest.result);\n  } catch (error) {\n    throw new Error(`${errorPrefix ?? ''}${error.message}`);\n  }\n  const validatedManifest = manifest;\n\n  const { iconPath } = validatedManifest.result.source.location.npm;\n  if (iconPath && !svgIcon) {\n    throw new Error(`Missing file \"${iconPath}\".`);\n  }\n\n  try {\n    assertIsNpmSnapPackageJson(packageJson.result);\n  } catch (error) {\n    throw new Error(`${errorPrefix ?? ''}${error.message}`);\n  }\n\n  const validatedPackageJson = packageJson;\n  await validateNpmSnapManifest({\n    manifest: validatedManifest,\n    packageJson: validatedPackageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  });\n\n  if (svgIcon) {\n    try {\n      assertIsSnapIcon(svgIcon);\n    } catch (error) {\n      throw new Error(`${errorPrefix ?? ''}${error.message}`);\n    }\n  }\n\n  if (localizationFiles) {\n    try {\n      // This function validates and returns the localization files. We don't\n      // use the return value here, but we do want to validate the files.\n      getValidatedLocalizationFiles(localizationFiles);\n\n      validateSnapManifestLocalizations(\n        manifest.result,\n        localizationFiles.map((file) => file.result),\n      );\n    } catch (error) {\n      throw new Error(`${errorPrefix ?? ''}${error.message}`);\n    }\n  }\n\n  return {\n    manifest: validatedManifest,\n    packageJson: validatedPackageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  };\n}\n"],"names":["EXPECTED_SNAP_FILES","SnapFileNameFromKey","validateNpmSnap","manifest","NpmSnapFileNames","Manifest","packageJson","PackageJson","sourceCode","snapFiles","errorPrefix","forEach","key","Error","svgIcon","auxiliaryFiles","localizationFiles","assertIsSnapManifest","result","error","message","validatedManifest","iconPath","source","location","npm","assertIsNpmSnapPackageJson","validatedPackageJson","validateNpmSnapManifest","assertIsSnapIcon","getValidatedLocalizationFiles","validateSnapManifestLocalizations","map","file"],"mappings":";;;;;;;;;;;IAUaA,mBAAmB;eAAnBA;;IAMAC,mBAAmB;eAAnBA;;IAkBSC,eAAe;eAAfA;;;sBAlCW;8BAI1B;0BACiC;4BACH;uBAEwB;AAEtD,MAAMF,sBAAsB;IACjC;IACA;IACA;CACD;AAEM,MAAMC,sBAAsB;IACjCE,UAAUC,uBAAgB,CAACC,QAAQ;IACnCC,aAAaF,uBAAgB,CAACG,WAAW;IACzCC,YAAY;AACd;AAcO,eAAeN,gBACpBO,SAA+B,EAC/BC,WAA2B;IAE3BV,oBAAoBW,OAAO,CAAC,CAACC;QAC3B,IAAI,CAACH,SAAS,CAACG,IAAI,EAAE;YACnB,MAAM,IAAIC,MACR,CAAC,EAAEH,eAAe,GAAG,cAAc,EAAET,mBAAmB,CAACW,IAAI,CAAC,EAAE,CAAC;QAErE;IACF;IAEA,yEAAyE;IACzE,MAAM,EACJT,QAAQ,EACRG,WAAW,EACXE,UAAU,EACVM,OAAO,EACPC,cAAc,EACdC,iBAAiB,EAClB,GAAGP;IAEJ,IAAI;QACFQ,IAAAA,gCAAoB,EAACd,SAASe,MAAM;IACtC,EAAE,OAAOC,OAAO;QACd,MAAM,IAAIN,MAAM,CAAC,EAAEH,eAAe,GAAG,EAAES,MAAMC,OAAO,CAAC,CAAC;IACxD;IACA,MAAMC,oBAAoBlB;IAE1B,MAAM,EAAEmB,QAAQ,EAAE,GAAGD,kBAAkBH,MAAM,CAACK,MAAM,CAACC,QAAQ,CAACC,GAAG;IACjE,IAAIH,YAAY,CAACR,SAAS;QACxB,MAAM,IAAID,MAAM,CAAC,cAAc,EAAES,SAAS,EAAE,CAAC;IAC/C;IAEA,IAAI;QACFI,IAAAA,iCAA0B,EAACpB,YAAYY,MAAM;IAC/C,EAAE,OAAOC,OAAO;QACd,MAAM,IAAIN,MAAM,CAAC,EAAEH,eAAe,GAAG,EAAES,MAAMC,OAAO,CAAC,CAAC;IACxD;IAEA,MAAMO,uBAAuBrB;IAC7B,MAAMsB,IAAAA,iCAAuB,EAAC;QAC5BzB,UAAUkB;QACVf,aAAaqB;QACbnB;QACAM;QACAC;QACAC;IACF;IAEA,IAAIF,SAAS;QACX,IAAI;YACFe,IAAAA,sBAAgB,EAACf;QACnB,EAAE,OAAOK,OAAO;YACd,MAAM,IAAIN,MAAM,CAAC,EAAEH,eAAe,GAAG,EAAES,MAAMC,OAAO,CAAC,CAAC;QACxD;IACF;IAEA,IAAIJ,mBAAmB;QACrB,IAAI;YACF,uEAAuE;YACvE,mEAAmE;YACnEc,IAAAA,2CAA6B,EAACd;YAE9Be,IAAAA,+CAAiC,EAC/B5B,SAASe,MAAM,EACfF,kBAAkBgB,GAAG,CAAC,CAACC,OAASA,KAAKf,MAAM;QAE/C,EAAE,OAAOC,OAAO;YACd,MAAM,IAAIN,MAAM,CAAC,EAAEH,eAAe,GAAG,EAAES,MAAMC,OAAO,CAAC,CAAC;QACxD;IACF;IAEA,OAAO;QACLjB,UAAUkB;QACVf,aAAaqB;QACbnB;QACAM;QACAC;QACAC;IACF;AACF"}