{"version":3,"sources":["../../../src/manifest/manifest.ts"],"sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { assertExhaustive, assert, isPlainObject } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport { promises as fs } from 'fs';\nimport pathUtils from 'path';\n\nimport { deepClone } from '../deep-clone';\nimport { readJsonFile } from '../fs';\nimport { validateNpmSnap } from '../npm';\nimport {\n  getSnapChecksum,\n  ProgrammaticallyFixableSnapError,\n  validateSnapShasum,\n} from '../snaps';\nimport type { SnapFiles, UnvalidatedSnapFiles } from '../types';\nimport { NpmSnapFileNames, SnapValidationFailureReason } from '../types';\nimport { readVirtualFile, VirtualFile } from '../virtual-file';\nimport type { SnapManifest } from './validation';\n\nconst MANIFEST_SORT_ORDER: Record<keyof SnapManifest, number> = {\n  $schema: 1,\n  version: 2,\n  description: 3,\n  proposedName: 4,\n  repository: 5,\n  source: 6,\n  initialConnections: 7,\n  initialPermissions: 8,\n  manifestVersion: 9,\n};\n\n/**\n * The result from the `checkManifest` function.\n *\n * @property manifest - The fixed manifest object.\n * @property updated - Whether the manifest was updated.\n * @property warnings - An array of warnings that were encountered during\n * processing of the manifest files. These warnings are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n * @property errors - An array of errors that were encountered during\n * processing of the manifest files. These errors are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n */\nexport type CheckManifestResult = {\n  manifest: SnapManifest;\n  updated?: boolean;\n  warnings: string[];\n  errors: string[];\n};\n\nexport type WriteFileFunction = (path: string, data: string) => Promise<void>;\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param writeManifest - Whether to write the fixed manifest to disk.\n * @param sourceCode - The source code of the Snap.\n * @param writeFileFn - The function to use to write the manifest to disk.\n * @returns Whether the manifest was updated, and an array of warnings that\n * were encountered during processing of the manifest files.\n */\nexport async function checkManifest(\n  basePath: string,\n  writeManifest = true,\n  sourceCode?: string,\n  writeFileFn: WriteFileFunction = fs.writeFile,\n): Promise<CheckManifestResult> {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  let updated = false;\n\n  const manifestPath = pathUtils.join(basePath, NpmSnapFileNames.Manifest);\n  const manifestFile = await readJsonFile(manifestPath);\n  const unvalidatedManifest = manifestFile.result;\n\n  const packageFile = await readJsonFile(\n    pathUtils.join(basePath, NpmSnapFileNames.PackageJson),\n  );\n\n  const auxiliaryFilePaths = getSnapFilePaths(\n    unvalidatedManifest,\n    (manifest) => manifest?.source?.files,\n  );\n\n  const localizationFilePaths = getSnapFilePaths(\n    unvalidatedManifest,\n    (manifest) => manifest?.source?.locales,\n  );\n\n  const snapFiles: UnvalidatedSnapFiles = {\n    manifest: manifestFile,\n    packageJson: packageFile,\n    sourceCode: await getSnapSourceCode(\n      basePath,\n      unvalidatedManifest,\n      sourceCode,\n    ),\n    svgIcon: await getSnapIcon(basePath, unvalidatedManifest),\n    // Intentionally pass null as the encoding here since the files may be binary\n    auxiliaryFiles:\n      (await getSnapFiles(basePath, auxiliaryFilePaths, null)) ?? [],\n    localizationFiles:\n      (await getSnapFiles(basePath, localizationFilePaths)) ?? [],\n  };\n\n  let manifest: VirtualFile<SnapManifest> | undefined;\n  try {\n    ({ manifest } = await validateNpmSnap(snapFiles));\n  } catch (error) {\n    if (error instanceof ProgrammaticallyFixableSnapError) {\n      errors.push(error.message);\n\n      // If we get here, the files at least have the correct shape.\n      const partiallyValidatedFiles = snapFiles as SnapFiles;\n\n      let isInvalid = true;\n      let currentError = error;\n      const maxAttempts = Object.keys(SnapValidationFailureReason).length;\n\n      // Attempt to fix all fixable validation failure reasons. All such reasons\n      // are enumerated by the `SnapValidationFailureReason` enum, so we only\n      // attempt to fix the manifest the same amount of times as there are\n      // reasons in the enum.\n      for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {\n        manifest = await fixManifest(\n          manifest\n            ? { ...partiallyValidatedFiles, manifest }\n            : partiallyValidatedFiles,\n          currentError,\n        );\n\n        try {\n          await validateNpmSnapManifest({\n            ...partiallyValidatedFiles,\n            manifest,\n          });\n\n          isInvalid = false;\n        } catch (nextValidationError) {\n          currentError = nextValidationError;\n          /* istanbul ignore next: this should be impossible */\n          if (\n            !(\n              nextValidationError instanceof ProgrammaticallyFixableSnapError\n            ) ||\n            (attempts === maxAttempts && !isInvalid)\n          ) {\n            throw new Error(\n              `Internal error: Failed to fix manifest. This is a bug, please report it. Reason:\\n${error.message}`,\n            );\n          }\n\n          errors.push(currentError.message);\n        }\n      }\n\n      updated = true;\n    } else {\n      throw error;\n    }\n  }\n\n  // TypeScript assumes `manifest` can still be undefined, that is not the case.\n  // But we assert to keep TypeScript happy.\n  assert(manifest);\n\n  const validatedManifest = manifest.result;\n\n  // Check presence of recommended keys\n  const recommendedFields = ['repository'] as const;\n\n  const missingRecommendedFields = recommendedFields.filter(\n    (key) => !validatedManifest[key],\n  );\n\n  if (missingRecommendedFields.length > 0) {\n    warnings.push(\n      `Missing recommended package.json properties:\\n${missingRecommendedFields.reduce(\n        (allMissing, currentField) => {\n          return `${allMissing}\\t${currentField}\\n`;\n        },\n        '',\n      )}`,\n    );\n  }\n\n  if (writeManifest) {\n    try {\n      const newManifest = `${JSON.stringify(\n        getWritableManifest(validatedManifest),\n        null,\n        2,\n      )}\\n`;\n\n      if (updated || newManifest !== manifestFile.value) {\n        await writeFileFn(\n          pathUtils.join(basePath, NpmSnapFileNames.Manifest),\n          newManifest,\n        );\n      }\n    } catch (error) {\n      // Note: This error isn't pushed to the errors array, because it's not an\n      // error in the manifest itself.\n      throw new Error(`Failed to update snap.manifest.json: ${error.message}`);\n    }\n  }\n\n  return { manifest: validatedManifest, updated, warnings, errors };\n}\n\n/**\n * Given the relevant Snap files (manifest, `package.json`, and bundle) and a\n * Snap manifest validation error, fixes the fault in the manifest that caused\n * the error.\n *\n * @param snapFiles - The contents of all Snap files.\n * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.\n * @returns A copy of the manifest file where the cause of the error is fixed.\n */\nexport async function fixManifest(\n  snapFiles: SnapFiles,\n  error: ProgrammaticallyFixableSnapError,\n): Promise<VirtualFile<SnapManifest>> {\n  const { manifest, packageJson } = snapFiles;\n  const clonedFile = manifest.clone();\n  const manifestCopy = clonedFile.result;\n\n  switch (error.reason) {\n    case SnapValidationFailureReason.NameMismatch:\n      manifestCopy.source.location.npm.packageName = packageJson.result.name;\n      break;\n\n    case SnapValidationFailureReason.VersionMismatch:\n      manifestCopy.version = packageJson.result.version;\n      break;\n\n    case SnapValidationFailureReason.RepositoryMismatch:\n      manifestCopy.repository = packageJson.result.repository\n        ? deepClone(packageJson.result.repository)\n        : undefined;\n      break;\n\n    case SnapValidationFailureReason.ShasumMismatch:\n      manifestCopy.source.shasum = await getSnapChecksum(snapFiles);\n      break;\n\n    /* istanbul ignore next */\n    default:\n      assertExhaustive(error.reason);\n  }\n\n  clonedFile.result = manifestCopy;\n  clonedFile.value = JSON.stringify(manifestCopy);\n  return clonedFile;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * bundle source file location and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param sourceCode - Override source code for plugins.\n * @returns The contents of the bundle file, if any.\n */\nexport async function getSnapSourceCode(\n  basePath: string,\n  manifest: Json,\n  sourceCode?: string,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const sourceFilePath = (manifest as Partial<SnapManifest>).source?.location\n    ?.npm?.filePath;\n\n  if (!sourceFilePath) {\n    return undefined;\n  }\n\n  if (sourceCode) {\n    return new VirtualFile({\n      path: pathUtils.join(basePath, sourceFilePath),\n      value: sourceCode,\n    });\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, sourceFilePath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(\n      `Failed to read snap bundle file: ${getErrorMessage(error)}`,\n    );\n  }\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * icon and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @returns The contents of the icon, if any.\n */\nexport async function getSnapIcon(\n  basePath: string,\n  manifest: Json,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const iconPath = (manifest as Partial<SnapManifest>).source?.location?.npm\n    ?.iconPath;\n\n  if (!iconPath) {\n    return undefined;\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, iconPath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read snap icon file: ${getErrorMessage(error)}`);\n  }\n}\n\n/**\n * Get an array of paths from an unvalidated Snap manifest.\n *\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param selector - A function that returns the paths to the files.\n * @returns The paths to the files, if any.\n */\nexport function getSnapFilePaths(\n  manifest: Json,\n  selector: (manifest: Partial<SnapManifest>) => string[] | undefined,\n) {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const snapManifest = manifest as Partial<SnapManifest>;\n  const paths = selector(snapManifest);\n\n  if (!Array.isArray(paths)) {\n    return undefined;\n  }\n\n  return paths;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the files with the\n * given paths and read them.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param paths - The paths to the files.\n * @param encoding - An optional encoding to pass down to readVirtualFile.\n * @returns A list of auxiliary files and their contents, if any.\n */\nexport async function getSnapFiles(\n  basePath: string,\n  paths: string[] | undefined,\n  encoding: BufferEncoding | null = 'utf8',\n): Promise<VirtualFile[] | undefined> {\n  if (!paths) {\n    return undefined;\n  }\n\n  try {\n    return await Promise.all(\n      paths.map(async (filePath) =>\n        readVirtualFile(pathUtils.join(basePath, filePath), encoding),\n      ),\n    );\n  } catch (error) {\n    throw new Error(`Failed to read snap files: ${getErrorMessage(error)}`);\n  }\n}\n\n/**\n * Sorts the given manifest in our preferred sort order and removes the\n * `repository` field if it is falsy (it may be `null`).\n *\n * @param manifest - The manifest to sort and modify.\n * @returns The disk-ready manifest.\n */\nexport function getWritableManifest(manifest: SnapManifest): SnapManifest {\n  const { repository, ...remaining } = manifest;\n\n  const keys = Object.keys(\n    repository ? { ...remaining, repository } : remaining,\n  ) as (keyof SnapManifest)[];\n\n  const writableManifest = keys\n    .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])\n    .reduce<Partial<SnapManifest>>(\n      (result, key) => ({\n        ...result,\n        [key]: manifest[key],\n      }),\n      {},\n    );\n\n  return writableManifest as SnapManifest;\n}\n\n/**\n * Validates the fields of an NPM Snap manifest that has already passed JSON\n * Schema validation.\n *\n * @param snapFiles - The relevant snap files to validate.\n * @param snapFiles.manifest - The npm Snap manifest to validate.\n * @param snapFiles.packageJson - The npm Snap's `package.json`.\n * @param snapFiles.sourceCode - The Snap's source code.\n * @param snapFiles.svgIcon - The Snap's optional icon.\n * @param snapFiles.auxiliaryFiles - Any auxiliary files required by the snap at runtime.\n * @param snapFiles.localizationFiles - The Snap's localization files.\n */\nexport async function validateNpmSnapManifest({\n  manifest,\n  packageJson,\n  sourceCode,\n  svgIcon,\n  auxiliaryFiles,\n  localizationFiles,\n}: SnapFiles) {\n  const packageJsonName = packageJson.result.name;\n  const packageJsonVersion = packageJson.result.version;\n  const packageJsonRepository = packageJson.result.repository;\n\n  const manifestPackageName = manifest.result.source.location.npm.packageName;\n  const manifestPackageVersion = manifest.result.version;\n  const manifestRepository = manifest.result.repository;\n\n  if (packageJsonName !== manifestPackageName) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package name (\"${manifestPackageName}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"name\" field (\"${packageJsonName}\").`,\n      SnapValidationFailureReason.NameMismatch,\n    );\n  }\n\n  if (packageJsonVersion !== manifestPackageVersion) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package version (\"${manifestPackageVersion}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"version\" field (\"${packageJsonVersion}\").`,\n      SnapValidationFailureReason.VersionMismatch,\n    );\n  }\n\n  if (\n    // The repository may be `undefined` in package.json but can only be defined\n    // or `null` in the Snap manifest due to TS@<4.4 issues.\n    (packageJsonRepository || manifestRepository) &&\n    !deepEqual(packageJsonRepository, manifestRepository)\n  ) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" \"repository\" field does not match the \"${NpmSnapFileNames.PackageJson}\" \"repository\" field.`,\n      SnapValidationFailureReason.RepositoryMismatch,\n    );\n  }\n\n  await validateSnapShasum(\n    { manifest, sourceCode, svgIcon, auxiliaryFiles, localizationFiles },\n    `\"${NpmSnapFileNames.Manifest}\" \"shasum\" field does not match computed shasum.`,\n  );\n}\n"],"names":["getErrorMessage","assertExhaustive","assert","isPlainObject","deepEqual","promises","fs","pathUtils","deepClone","readJsonFile","validateNpmSnap","getSnapChecksum","ProgrammaticallyFixableSnapError","validateSnapShasum","NpmSnapFileNames","SnapValidationFailureReason","readVirtualFile","VirtualFile","MANIFEST_SORT_ORDER","$schema","version","description","proposedName","repository","source","initialConnections","initialPermissions","manifestVersion","checkManifest","basePath","writeManifest","sourceCode","writeFileFn","writeFile","warnings","errors","updated","manifestPath","join","Manifest","manifestFile","unvalidatedManifest","result","packageFile","PackageJson","auxiliaryFilePaths","getSnapFilePaths","manifest","files","localizationFilePaths","locales","snapFiles","packageJson","getSnapSourceCode","svgIcon","getSnapIcon","auxiliaryFiles","getSnapFiles","localizationFiles","error","push","message","partiallyValidatedFiles","isInvalid","currentError","maxAttempts","Object","keys","length","attempts","fixManifest","validateNpmSnapManifest","nextValidationError","Error","validatedManifest","recommendedFields","missingRecommendedFields","filter","key","reduce","allMissing","currentField","newManifest","JSON","stringify","getWritableManifest","value","clonedFile","clone","manifestCopy","reason","NameMismatch","location","npm","packageName","name","VersionMismatch","RepositoryMismatch","undefined","ShasumMismatch","shasum","sourceFilePath","filePath","path","virtualFile","iconPath","selector","snapManifest","paths","Array","isArray","encoding","Promise","all","map","remaining","writableManifest","sort","a","b","packageJsonName","packageJsonVersion","packageJsonRepository","manifestPackageName","manifestPackageVersion","manifestRepository"],"mappings":"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"}