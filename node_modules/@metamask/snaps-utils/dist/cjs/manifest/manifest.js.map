{"version":3,"sources":["../../../src/manifest/manifest.ts"],"sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { assertExhaustive, assert, isPlainObject } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport { promises as fs } from 'fs';\nimport pathUtils from 'path';\n\nimport { deepClone } from '../deep-clone';\nimport { readJsonFile } from '../fs';\nimport { validateNpmSnap } from '../npm';\nimport {\n  getSnapChecksum,\n  ProgrammaticallyFixableSnapError,\n  validateSnapShasum,\n} from '../snaps';\nimport type { SnapFiles, UnvalidatedSnapFiles } from '../types';\nimport { NpmSnapFileNames, SnapValidationFailureReason } from '../types';\nimport { readVirtualFile, VirtualFile } from '../virtual-file';\nimport type { SnapManifest } from './validation';\n\nconst MANIFEST_SORT_ORDER: Record<keyof SnapManifest, number> = {\n  $schema: 1,\n  version: 2,\n  description: 3,\n  proposedName: 4,\n  repository: 5,\n  source: 6,\n  initialConnections: 7,\n  initialPermissions: 8,\n  manifestVersion: 9,\n};\n\n/**\n * The result from the `checkManifest` function.\n *\n * @property manifest - The fixed manifest object.\n * @property updated - Whether the manifest was updated.\n * @property warnings - An array of warnings that were encountered during\n * processing of the manifest files. These warnings are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n * @property errors - An array of errors that were encountered during\n * processing of the manifest files. These errors are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n */\nexport type CheckManifestResult = {\n  manifest: SnapManifest;\n  updated?: boolean;\n  warnings: string[];\n  errors: string[];\n};\n\nexport type WriteFileFunction = (path: string, data: string) => Promise<void>;\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param writeManifest - Whether to write the fixed manifest to disk.\n * @param sourceCode - The source code of the Snap.\n * @param writeFileFn - The function to use to write the manifest to disk.\n * @returns Whether the manifest was updated, and an array of warnings that\n * were encountered during processing of the manifest files.\n */\nexport async function checkManifest(\n  basePath: string,\n  writeManifest = true,\n  sourceCode?: string,\n  writeFileFn: WriteFileFunction = fs.writeFile,\n): Promise<CheckManifestResult> {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  let updated = false;\n\n  const manifestPath = pathUtils.join(basePath, NpmSnapFileNames.Manifest);\n  const manifestFile = await readJsonFile(manifestPath);\n  const unvalidatedManifest = manifestFile.result;\n\n  const packageFile = await readJsonFile(\n    pathUtils.join(basePath, NpmSnapFileNames.PackageJson),\n  );\n\n  const auxiliaryFilePaths = getSnapFilePaths(\n    unvalidatedManifest,\n    (manifest) => manifest?.source?.files,\n  );\n\n  const localizationFilePaths = getSnapFilePaths(\n    unvalidatedManifest,\n    (manifest) => manifest?.source?.locales,\n  );\n\n  const snapFiles: UnvalidatedSnapFiles = {\n    manifest: manifestFile,\n    packageJson: packageFile,\n    sourceCode: await getSnapSourceCode(\n      basePath,\n      unvalidatedManifest,\n      sourceCode,\n    ),\n    svgIcon: await getSnapIcon(basePath, unvalidatedManifest),\n    // Intentionally pass null as the encoding here since the files may be binary\n    auxiliaryFiles:\n      (await getSnapFiles(basePath, auxiliaryFilePaths, null)) ?? [],\n    localizationFiles:\n      (await getSnapFiles(basePath, localizationFilePaths)) ?? [],\n  };\n\n  let manifest: VirtualFile<SnapManifest> | undefined;\n  try {\n    ({ manifest } = await validateNpmSnap(snapFiles));\n  } catch (error) {\n    if (error instanceof ProgrammaticallyFixableSnapError) {\n      errors.push(error.message);\n\n      // If we get here, the files at least have the correct shape.\n      const partiallyValidatedFiles = snapFiles as SnapFiles;\n\n      let isInvalid = true;\n      let currentError = error;\n      const maxAttempts = Object.keys(SnapValidationFailureReason).length;\n\n      // Attempt to fix all fixable validation failure reasons. All such reasons\n      // are enumerated by the `SnapValidationFailureReason` enum, so we only\n      // attempt to fix the manifest the same amount of times as there are\n      // reasons in the enum.\n      for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {\n        manifest = await fixManifest(\n          manifest\n            ? { ...partiallyValidatedFiles, manifest }\n            : partiallyValidatedFiles,\n          currentError,\n        );\n\n        try {\n          await validateNpmSnapManifest({\n            ...partiallyValidatedFiles,\n            manifest,\n          });\n\n          isInvalid = false;\n        } catch (nextValidationError) {\n          currentError = nextValidationError;\n          /* istanbul ignore next: this should be impossible */\n          if (\n            !(\n              nextValidationError instanceof ProgrammaticallyFixableSnapError\n            ) ||\n            (attempts === maxAttempts && !isInvalid)\n          ) {\n            throw new Error(\n              `Internal error: Failed to fix manifest. This is a bug, please report it. Reason:\\n${error.message}`,\n            );\n          }\n\n          errors.push(currentError.message);\n        }\n      }\n\n      updated = true;\n    } else {\n      throw error;\n    }\n  }\n\n  // TypeScript assumes `manifest` can still be undefined, that is not the case.\n  // But we assert to keep TypeScript happy.\n  assert(manifest);\n\n  const validatedManifest = manifest.result;\n\n  // Check presence of recommended keys\n  const recommendedFields = ['repository'] as const;\n\n  const missingRecommendedFields = recommendedFields.filter(\n    (key) => !validatedManifest[key],\n  );\n\n  if (missingRecommendedFields.length > 0) {\n    warnings.push(\n      `Missing recommended package.json properties:\\n${missingRecommendedFields.reduce(\n        (allMissing, currentField) => {\n          return `${allMissing}\\t${currentField}\\n`;\n        },\n        '',\n      )}`,\n    );\n  }\n\n  if (writeManifest) {\n    try {\n      const newManifest = `${JSON.stringify(\n        getWritableManifest(validatedManifest),\n        null,\n        2,\n      )}\\n`;\n\n      if (updated || newManifest !== manifestFile.value) {\n        await writeFileFn(\n          pathUtils.join(basePath, NpmSnapFileNames.Manifest),\n          newManifest,\n        );\n      }\n    } catch (error) {\n      // Note: This error isn't pushed to the errors array, because it's not an\n      // error in the manifest itself.\n      throw new Error(`Failed to update snap.manifest.json: ${error.message}`);\n    }\n  }\n\n  return { manifest: validatedManifest, updated, warnings, errors };\n}\n\n/**\n * Given the relevant Snap files (manifest, `package.json`, and bundle) and a\n * Snap manifest validation error, fixes the fault in the manifest that caused\n * the error.\n *\n * @param snapFiles - The contents of all Snap files.\n * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.\n * @returns A copy of the manifest file where the cause of the error is fixed.\n */\nexport async function fixManifest(\n  snapFiles: SnapFiles,\n  error: ProgrammaticallyFixableSnapError,\n): Promise<VirtualFile<SnapManifest>> {\n  const { manifest, packageJson } = snapFiles;\n  const clonedFile = manifest.clone();\n  const manifestCopy = clonedFile.result;\n\n  switch (error.reason) {\n    case SnapValidationFailureReason.NameMismatch:\n      manifestCopy.source.location.npm.packageName = packageJson.result.name;\n      break;\n\n    case SnapValidationFailureReason.VersionMismatch:\n      manifestCopy.version = packageJson.result.version;\n      break;\n\n    case SnapValidationFailureReason.RepositoryMismatch:\n      manifestCopy.repository = packageJson.result.repository\n        ? deepClone(packageJson.result.repository)\n        : undefined;\n      break;\n\n    case SnapValidationFailureReason.ShasumMismatch:\n      manifestCopy.source.shasum = await getSnapChecksum(snapFiles);\n      break;\n\n    /* istanbul ignore next */\n    default:\n      assertExhaustive(error.reason);\n  }\n\n  clonedFile.result = manifestCopy;\n  clonedFile.value = JSON.stringify(manifestCopy);\n  return clonedFile;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * bundle source file location and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param sourceCode - Override source code for plugins.\n * @returns The contents of the bundle file, if any.\n */\nexport async function getSnapSourceCode(\n  basePath: string,\n  manifest: Json,\n  sourceCode?: string,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const sourceFilePath = (manifest as Partial<SnapManifest>).source?.location\n    ?.npm?.filePath;\n\n  if (!sourceFilePath) {\n    return undefined;\n  }\n\n  if (sourceCode) {\n    return new VirtualFile({\n      path: pathUtils.join(basePath, sourceFilePath),\n      value: sourceCode,\n    });\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, sourceFilePath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(\n      `Failed to read snap bundle file: ${getErrorMessage(error)}`,\n    );\n  }\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * icon and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @returns The contents of the icon, if any.\n */\nexport async function getSnapIcon(\n  basePath: string,\n  manifest: Json,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const iconPath = (manifest as Partial<SnapManifest>).source?.location?.npm\n    ?.iconPath;\n\n  if (!iconPath) {\n    return undefined;\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, iconPath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read snap icon file: ${getErrorMessage(error)}`);\n  }\n}\n\n/**\n * Get an array of paths from an unvalidated Snap manifest.\n *\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param selector - A function that returns the paths to the files.\n * @returns The paths to the files, if any.\n */\nexport function getSnapFilePaths(\n  manifest: Json,\n  selector: (manifest: Partial<SnapManifest>) => string[] | undefined,\n) {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const snapManifest = manifest as Partial<SnapManifest>;\n  const paths = selector(snapManifest);\n\n  if (!Array.isArray(paths)) {\n    return undefined;\n  }\n\n  return paths;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the files with the\n * given paths and read them.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param paths - The paths to the files.\n * @param encoding - An optional encoding to pass down to readVirtualFile.\n * @returns A list of auxiliary files and their contents, if any.\n */\nexport async function getSnapFiles(\n  basePath: string,\n  paths: string[] | undefined,\n  encoding: BufferEncoding | null = 'utf8',\n): Promise<VirtualFile[] | undefined> {\n  if (!paths) {\n    return undefined;\n  }\n\n  try {\n    return await Promise.all(\n      paths.map(async (filePath) =>\n        readVirtualFile(pathUtils.join(basePath, filePath), encoding),\n      ),\n    );\n  } catch (error) {\n    throw new Error(`Failed to read snap files: ${getErrorMessage(error)}`);\n  }\n}\n\n/**\n * Sorts the given manifest in our preferred sort order and removes the\n * `repository` field if it is falsy (it may be `null`).\n *\n * @param manifest - The manifest to sort and modify.\n * @returns The disk-ready manifest.\n */\nexport function getWritableManifest(manifest: SnapManifest): SnapManifest {\n  const { repository, ...remaining } = manifest;\n\n  const keys = Object.keys(\n    repository ? { ...remaining, repository } : remaining,\n  ) as (keyof SnapManifest)[];\n\n  const writableManifest = keys\n    .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])\n    .reduce<Partial<SnapManifest>>(\n      (result, key) => ({\n        ...result,\n        [key]: manifest[key],\n      }),\n      {},\n    );\n\n  return writableManifest as SnapManifest;\n}\n\n/**\n * Validates the fields of an NPM Snap manifest that has already passed JSON\n * Schema validation.\n *\n * @param snapFiles - The relevant snap files to validate.\n * @param snapFiles.manifest - The npm Snap manifest to validate.\n * @param snapFiles.packageJson - The npm Snap's `package.json`.\n * @param snapFiles.sourceCode - The Snap's source code.\n * @param snapFiles.svgIcon - The Snap's optional icon.\n * @param snapFiles.auxiliaryFiles - Any auxiliary files required by the snap at runtime.\n * @param snapFiles.localizationFiles - The Snap's localization files.\n */\nexport async function validateNpmSnapManifest({\n  manifest,\n  packageJson,\n  sourceCode,\n  svgIcon,\n  auxiliaryFiles,\n  localizationFiles,\n}: SnapFiles) {\n  const packageJsonName = packageJson.result.name;\n  const packageJsonVersion = packageJson.result.version;\n  const packageJsonRepository = packageJson.result.repository;\n\n  const manifestPackageName = manifest.result.source.location.npm.packageName;\n  const manifestPackageVersion = manifest.result.version;\n  const manifestRepository = manifest.result.repository;\n\n  if (packageJsonName !== manifestPackageName) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package name (\"${manifestPackageName}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"name\" field (\"${packageJsonName}\").`,\n      SnapValidationFailureReason.NameMismatch,\n    );\n  }\n\n  if (packageJsonVersion !== manifestPackageVersion) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package version (\"${manifestPackageVersion}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"version\" field (\"${packageJsonVersion}\").`,\n      SnapValidationFailureReason.VersionMismatch,\n    );\n  }\n\n  if (\n    // The repository may be `undefined` in package.json but can only be defined\n    // or `null` in the Snap manifest due to TS@<4.4 issues.\n    (packageJsonRepository || manifestRepository) &&\n    !deepEqual(packageJsonRepository, manifestRepository)\n  ) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" \"repository\" field does not match the \"${NpmSnapFileNames.PackageJson}\" \"repository\" field.`,\n      SnapValidationFailureReason.RepositoryMismatch,\n    );\n  }\n\n  await validateSnapShasum(\n    { manifest, sourceCode, svgIcon, auxiliaryFiles, localizationFiles },\n    `\"${NpmSnapFileNames.Manifest}\" \"shasum\" field does not match computed shasum.`,\n  );\n}\n"],"names":["checkManifest","fixManifest","getSnapSourceCode","getSnapIcon","getSnapFilePaths","getSnapFiles","getWritableManifest","validateNpmSnapManifest","MANIFEST_SORT_ORDER","$schema","version","description","proposedName","repository","source","initialConnections","initialPermissions","manifestVersion","basePath","writeManifest","sourceCode","writeFileFn","fs","writeFile","warnings","errors","updated","manifestPath","pathUtils","join","NpmSnapFileNames","Manifest","manifestFile","readJsonFile","unvalidatedManifest","result","packageFile","PackageJson","auxiliaryFilePaths","manifest","files","localizationFilePaths","locales","snapFiles","packageJson","svgIcon","auxiliaryFiles","localizationFiles","validateNpmSnap","error","ProgrammaticallyFixableSnapError","push","message","partiallyValidatedFiles","isInvalid","currentError","maxAttempts","Object","keys","SnapValidationFailureReason","length","attempts","nextValidationError","Error","assert","validatedManifest","recommendedFields","missingRecommendedFields","filter","key","reduce","allMissing","currentField","newManifest","JSON","stringify","value","clonedFile","clone","manifestCopy","reason","NameMismatch","location","npm","packageName","name","VersionMismatch","RepositoryMismatch","deepClone","undefined","ShasumMismatch","shasum","getSnapChecksum","assertExhaustive","isPlainObject","sourceFilePath","filePath","VirtualFile","path","virtualFile","readVirtualFile","getErrorMessage","iconPath","selector","snapManifest","paths","Array","isArray","encoding","Promise","all","map","remaining","writableManifest","sort","a","b","packageJsonName","packageJsonVersion","packageJsonRepository","manifestPackageName","manifestPackageVersion","manifestRepository","deepEqual","validateSnapShasum"],"mappings":"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"}