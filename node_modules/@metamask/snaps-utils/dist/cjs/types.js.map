{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\nimport { assertStruct, VersionStruct } from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  instance,\n  is,\n  object,\n  optional,\n  pattern,\n  refine,\n  size,\n  string,\n  type,\n  union,\n  assert as assertSuperstruct,\n} from 'superstruct';\n\nimport type { SnapCaveatType } from './caveats';\nimport type { SnapFunctionExports, SnapRpcHookArgs } from './handlers';\nimport type { LocalizationFile } from './localization';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport enum NpmSnapFileNames {\n  PackageJson = 'package.json',\n  Manifest = 'snap.manifest.json',\n}\n\nexport const NameStruct = size(\n  pattern(\n    string(),\n    /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$/u,\n  ),\n  1,\n  214,\n);\n\n// Note we use `type` instead of `object` here, because the latter does not\n// allow unknown keys.\nexport const NpmSnapPackageJsonStruct = type({\n  version: VersionStruct,\n  name: NameStruct,\n  main: optional(size(string(), 1, Infinity)),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n});\n\nexport type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> &\n  Record<string, any>;\n\n/**\n * Check if the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link NpmSnapPackageJson} object.\n */\nexport function isNpmSnapPackageJson(\n  value: unknown,\n): value is NpmSnapPackageJson {\n  return is(value, NpmSnapPackageJsonStruct);\n}\n\n/**\n * Asserts that the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link NpmSnapPackageJson} object.\n */\nexport function assertIsNpmSnapPackageJson(\n  value: unknown,\n): asserts value is NpmSnapPackageJson {\n  assertStruct(\n    value,\n    NpmSnapPackageJsonStruct,\n    `\"${NpmSnapFileNames.PackageJson}\" is invalid`,\n  );\n}\n\n/**\n * An object for storing parsed but unvalidated Snap file contents.\n */\nexport type UnvalidatedSnapFiles = {\n  manifest?: VirtualFile<Json>;\n  packageJson?: VirtualFile<Json>;\n  sourceCode?: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile[];\n};\n\n/**\n * An object for storing the contents of Snap files that have passed JSON\n * Schema validation, or are non-empty if they are strings.\n */\nexport type SnapFiles = {\n  manifest: VirtualFile<SnapManifest>;\n  packageJson: VirtualFile<NpmSnapPackageJson>;\n  sourceCode: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile<LocalizationFile>[];\n};\n\n/**\n * A subset of snap files extracted from a fetched snap.\n */\nexport type FetchedSnapFiles = Pick<\n  SnapFiles,\n  'manifest' | 'sourceCode' | 'svgIcon' | 'auxiliaryFiles' | 'localizationFiles'\n>;\n\n/**\n * The possible prefixes for snap ids.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SnapIdPrefixes {\n  npm = 'npm:',\n  local = 'local:',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/**\n * Snap validation failure reason codes that are programmatically fixable\n * if validation occurs during development.\n */\nexport enum SnapValidationFailureReason {\n  NameMismatch = '\"name\" field mismatch',\n  VersionMismatch = '\"version\" field mismatch',\n  RepositoryMismatch = '\"repository\" field mismatch',\n  ShasumMismatch = '\"shasum\" field mismatch',\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SNAP_STREAM_NAMES {\n  JSON_RPC = 'jsonRpc',\n  COMMAND = 'command',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// The snap is the callee\nexport type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;\n\ntype ObjectParameters<\n  Type extends Record<string, (...args: any[]) => unknown>,\n> = Parameters<Type[keyof Type]>;\n\nexport type SnapExportsParameters = ObjectParameters<SnapFunctionExports>;\n\ntype UriOptions<Type extends string> = {\n  protocol?: Struct<Type>;\n  hash?: Struct<Type>;\n  port?: Struct<Type>;\n  hostname?: Struct<Type>;\n  pathname?: Struct<Type>;\n  search?: Struct<Type>;\n};\n\nexport const uri = (opts: UriOptions<any> = {}) =>\n  refine(union([string(), instance(URL)]), 'uri', (value) => {\n    try {\n      const url = new URL(value);\n\n      const UrlStruct = type(opts);\n      assertSuperstruct(url, UrlStruct);\n      return true;\n    } catch {\n      return `Expected URL, got \"${value.toString()}\".`;\n    }\n  });\n\n/**\n * Returns whether a given value is a valid URL.\n *\n * @param url - The value to check.\n * @param opts - Optional constraints for url checking.\n * @returns Whether `url` is valid URL or not.\n */\nexport function isValidUrl(\n  url: unknown,\n  opts: UriOptions<any> = {},\n): url is string | URL {\n  return is(url, uri(opts));\n}\n\n// redefining here to avoid circular dependency\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\nexport type SnapsPermissionRequest = {\n  [WALLET_SNAP_PERMISSION_KEY]: {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds;\n        value: Record<string, Json>;\n      },\n    ];\n  };\n};\n"],"names":["NameStruct","NpmSnapPackageJsonStruct","isNpmSnapPackageJson","assertIsNpmSnapPackageJson","uri","isValidUrl","WALLET_SNAP_PERMISSION_KEY","NpmSnapFileNames","PackageJson","Manifest","size","pattern","string","type","version","VersionStruct","name","main","optional","Infinity","repository","object","url","value","is","assertStruct","SnapIdPrefixes","npm","local","SnapValidationFailureReason","NameMismatch","VersionMismatch","RepositoryMismatch","ShasumMismatch","SNAP_STREAM_NAMES","JSON_RPC","COMMAND","opts","refine","union","instance","URL","UrlStruct","assertSuperstruct","toString"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;IA4BaA,UAAU;eAAVA;;IAWAC,wBAAwB;eAAxBA;;IAqBGC,oBAAoB;eAApBA;;IAYAC,0BAA0B;eAA1BA;;IAyFHC,GAAG;eAAHA;;IAoBGC,UAAU;eAAVA;;IAQHC,0BAA0B;eAA1BA;;;uBA5L+B;6BAcrC;IAQA;UAAKC,gBAAgB;IAAhBA,iBACVC,iBAAc;IADJD,iBAEVE,cAAW;GAFDF,qBAAAA;AAKL,MAAMP,aAAaU,IAAAA,iBAAI,EAC5BC,IAAAA,oBAAO,EACLC,IAAAA,mBAAM,KACN,gEAEF,GACA;AAKK,MAAMX,2BAA2BY,IAAAA,iBAAI,EAAC;IAC3CC,SAASC,oBAAa;IACtBC,MAAMhB;IACNiB,MAAMC,IAAAA,qBAAQ,EAACR,IAAAA,iBAAI,EAACE,IAAAA,mBAAM,KAAI,GAAGO;IACjCC,YAAYF,IAAAA,qBAAQ,EAClBG,IAAAA,mBAAM,EAAC;QACLR,MAAMH,IAAAA,iBAAI,EAACE,IAAAA,mBAAM,KAAI,GAAGO;QACxBG,KAAKZ,IAAAA,iBAAI,EAACE,IAAAA,mBAAM,KAAI,GAAGO;IACzB;AAEJ;AAWO,SAASjB,qBACdqB,KAAc;IAEd,OAAOC,IAAAA,eAAE,EAACD,OAAOtB;AACnB;AAQO,SAASE,2BACdoB,KAAc;IAEdE,IAAAA,mBAAY,EACVF,OACAtB,0BACA,CAAC,CAAC,EAAEM,iBAAiBC,WAAW,CAAC,YAAY,CAAC;AAElD;IAuCO;UAAKkB,cAAc;IAAdA,eACVC,SAAM;IADID,eAEVE,WAAQ;GAFEF,mBAAAA;IAUL;UAAKG,2BAA2B;IAA3BA,4BACVC,kBAAe;IADLD,4BAEVE,qBAAkB;IAFRF,4BAGVG,wBAAqB;IAHXH,4BAIVI,oBAAiB;GAJPJ,gCAAAA;IAQL;UAAKK,iBAAiB;IAAjBA,kBACVC,cAAW;IADDD,kBAEVE,aAAU;GAFAF,sBAAAA;AAwBL,MAAM9B,MAAM,CAACiC,OAAwB,CAAC,CAAC,GAC5CC,IAAAA,mBAAM,EAACC,IAAAA,kBAAK,EAAC;QAAC3B,IAAAA,mBAAM;QAAI4B,IAAAA,qBAAQ,EAACC;KAAK,GAAG,OAAO,CAAClB;QAC/C,IAAI;YACF,MAAMD,MAAM,IAAImB,IAAIlB;YAEpB,MAAMmB,YAAY7B,IAAAA,iBAAI,EAACwB;YACvBM,IAAAA,mBAAiB,EAACrB,KAAKoB;YACvB,OAAO;QACT,EAAE,OAAM;YACN,OAAO,CAAC,mBAAmB,EAAEnB,MAAMqB,QAAQ,GAAG,EAAE,CAAC;QACnD;IACF;AASK,SAASvC,WACdiB,GAAY,EACZe,OAAwB,CAAC,CAAC;IAE1B,OAAOb,IAAAA,eAAE,EAACF,KAAKlB,IAAIiC;AACrB;AAGO,MAAM/B,6BAA6B"}