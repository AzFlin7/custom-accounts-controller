import type { Infer } from 'superstruct';
import type { SnapManifest } from './manifest';
import type { VirtualFile } from './virtual-file';
export declare const LOCALIZABLE_FIELDS: readonly ["description", "proposedName"];
export declare const LocalizationFileStruct: import("superstruct").Struct<{
    locale: string;
    messages: Record<string, {
        message: string;
        description?: string | undefined;
    }>;
}, {
    locale: import("superstruct").Struct<string, null>;
    messages: import("superstruct").Struct<Record<string, {
        message: string;
        description?: string | undefined;
    }>, null>;
}>;
export declare type LocalizationFile = Infer<typeof LocalizationFileStruct>;
/**
 * Validate a list of localization files.
 *
 * @param localizationFiles - The localization files to validate.
 * @returns The validated localization files.
 * @throws If any of the files are considered invalid.
 */
export declare function getValidatedLocalizationFiles(localizationFiles: VirtualFile[]): VirtualFile<LocalizationFile>[];
/**
 * Get the localization file for a given locale. If the locale is not found,
 * the English localization file will be returned.
 *
 * @param locale - The locale to use.
 * @param localizationFiles - The localization files to use.
 * @returns The localization file, or `undefined` if no localization file was
 * found.
 */
export declare function getLocalizationFile(locale: string, localizationFiles: LocalizationFile[]): {
    locale: string;
    messages: Record<string, {
        message: string;
        description?: string | undefined;
    }>;
} | undefined;
export declare const TRANSLATION_REGEX: RegExp;
/**
 * Translate a string using a localization file. This will replace all instances
 * of `{{key}}` with the localized version of `key`.
 *
 * @param value - The string to translate.
 * @param file - The localization file to use, or `undefined` if no localization
 * file was found.
 * @returns The translated string.
 * @throws If the string contains a key that is not present in the localization
 * file, or if no localization file was found.
 */
export declare function translate(value: string, file: LocalizationFile | undefined): string;
/**
 * Get the localized Snap manifest for a given locale. This will replace all
 * localized strings in the manifest with the localized version.
 *
 * @param snapManifest - The Snap manifest to localize.
 * @param locale - The locale to use.
 * @param localizationFiles - The localization files to use.
 * @returns The localized Snap manifest.
 */
export declare function getLocalizedSnapManifest(snapManifest: SnapManifest, locale: string, localizationFiles: LocalizationFile[]): {
    description: string;
    version: import("@metamask/utils").SemVerVersion;
    source: {
        location: {
            npm: {
                registry: "https://registry.npmjs.org" | "https://registry.npmjs.org/";
                filePath: string;
                packageName: string;
                iconPath?: string | undefined;
            };
        };
        shasum: string;
        files?: string[] | undefined;
        locales?: string[] | undefined;
    };
    proposedName: string;
    initialPermissions: {
        snap_dialog?: {} | undefined;
        snap_getBip32Entropy?: {
            path: string[];
            curve: "ed25519" | "secp256k1";
        }[] | undefined;
        snap_getBip32PublicKey?: {
            path: string[];
            curve: "ed25519" | "secp256k1";
        }[] | undefined;
        snap_getBip44Entropy?: {
            coinType: number;
        }[] | undefined;
        snap_getEntropy?: {} | undefined;
        snap_getLocale?: {} | undefined;
        snap_manageAccounts?: {} | undefined;
        snap_manageState?: {} | undefined;
        snap_notify?: {} | undefined;
        wallet_snap?: Record<string, {
            version?: string | undefined;
        }> | undefined;
        'endowment:ethereum-provider'?: {} | undefined;
        'endowment:network-access'?: {} | undefined;
        'endowment:webassembly'?: {} | undefined;
        'endowment:signature-insight'?: {
            allowSignatureOrigin?: boolean | undefined;
        } | undefined;
        'endowment:transaction-insight'?: {
            allowTransactionOrigin?: boolean | undefined;
        } | undefined;
        'endowment:cronjob'?: {
            jobs: {
                request: {
                    method: string;
                    id?: string | number | null | undefined;
                    jsonrpc?: "2.0" | undefined;
                    params?: Record<string, import("@metamask/snaps-sdk").Json> | import("@metamask/snaps-sdk").Json[] | undefined;
                };
                expression: string;
            }[];
        } | undefined;
        'endowment:rpc'?: {
            dapps?: boolean | undefined;
            snaps?: boolean | undefined;
            allowedOrigins?: string[] | undefined;
        } | undefined;
        'endowment:name-lookup'?: `${string}:${string}`[] | undefined;
        'endowment:keyring'?: {
            allowedOrigins?: string[] | undefined;
        } | undefined;
        snap_confirm?: {} | undefined;
    };
    manifestVersion: "0.1";
    repository?: {
        type: string;
        url: string;
    } | undefined;
    initialConnections?: Record<string & URL, {}> | undefined;
    $schema?: string | undefined;
};
/**
 * Validate the localization files for a Snap manifest.
 *
 * @param snapManifest - The Snap manifest to validate.
 * @param localizationFiles - The localization files to validate.
 * @throws If the manifest cannot be localized.
 */
export declare function validateSnapManifestLocalizations(snapManifest: SnapManifest, localizationFiles: LocalizationFile[]): void;
