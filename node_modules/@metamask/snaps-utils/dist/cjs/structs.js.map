{"version":3,"sources":["../../src/structs.ts"],"sourcesContent":["import { isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport { resolve } from 'path';\nimport type { Failure } from 'superstruct';\nimport { Struct, StructError, create, string, coerce } from 'superstruct';\nimport type { AnyStruct } from 'superstruct/dist/utils';\n\nimport { indent } from './strings';\n\n/**\n * Infer a struct type, only if it matches the specified type. This is useful\n * for defining types and structs that are related to each other in separate\n * files.\n *\n * @example\n * ```typescript\n * // In file A\n * export type GetFileArgs = {\n *   path: string;\n *   encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n * };\n *\n * // In file B\n * export const GetFileArgsStruct = object(...);\n *\n * // If the type and struct are in the same file, this will return the type.\n * // Otherwise, it will return `never`.\n * export type GetFileArgs =\n *   InferMatching<typeof GetFileArgsStruct, GetFileArgs>;\n * ```\n */\nexport type InferMatching<\n  StructType extends Struct<any, any>,\n  Type,\n> = StructType['TYPE'] extends Type ? Type : never;\n\n/**\n * A wrapper of `superstruct`'s `string` struct that coerces a value to a string\n * and resolves it relative to the current working directory. This is useful\n * for specifying file paths in a configuration file, as it allows the user to\n * use both relative and absolute paths.\n *\n * @returns The `superstruct` struct, which validates that the value is a\n * string, and resolves it relative to the current working directory.\n * @example\n * ```ts\n * const config = struct({\n *   file: file(),\n *   // ...\n * });\n *\n * const value = create({ file: 'path/to/file' }, config);\n * console.log(value.file); // /process/cwd/path/to/file\n * ```\n */\nexport function file() {\n  return coerce(string(), string(), (value) => {\n    return resolve(process.cwd(), value);\n  });\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(struct, [\n      ...failures(),\n    ])}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(struct, prefix, suffix, error, () =>\n    arrayToGenerator(error.failures()),\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => green(type));\n  }\n\n  return null;\n}\n\n/**\n * Get a error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${bold(failure.path.join('.'))} — `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n) {\n  const received = red(JSON.stringify(failure.value));\n  const prefix = getStructErrorPrefix(failure);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(/the literal `(.+)`,/u, `the value to be \\`${green('$1')}\\`,`)\n      .replace(/, but received: (.+)/u, `, but received: ${red('$1')}`);\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${bold(\n      failure.path.join('.'),\n    )}, received: ${received}.`;\n  }\n\n  return `${prefix}Expected a value of type ${green(\n    failure.type,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(`• ${getStructFailureMessage(struct, failure)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n"],"names":["file","named","SnapsStructError","arrayToGenerator","getError","createFromStruct","getStructFromPath","getUnionStructNames","getStructErrorPrefix","getStructFailureMessage","getStructErrorMessage","coerce","string","value","resolve","process","cwd","name","struct","Struct","type","StructError","constructor","prefix","suffix","failure","failures","message","array","item","error","create","path","reduce","result","key","isObject","schema","Array","isArray","map","green","length","bold","join","received","red","JSON","stringify","childStruct","unionNames","replace","formattedFailures","indent"],"mappings":"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"}