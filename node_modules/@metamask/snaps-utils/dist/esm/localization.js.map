{"version":3,"sources":["../../src/localization.ts"],"sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Infer } from 'superstruct';\nimport {\n  create,\n  object,\n  optional,\n  record,\n  string,\n  StructError,\n} from 'superstruct';\n\nimport { parseJson } from './json';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport const LOCALIZABLE_FIELDS = ['description', 'proposedName'] as const;\n\nexport const LocalizationFileStruct = object({\n  locale: string(),\n  messages: record(\n    string(),\n    object({\n      message: string(),\n      description: optional(string()),\n    }),\n  ),\n});\n\nexport type LocalizationFile = Infer<typeof LocalizationFileStruct>;\n\n/**\n * Validate a list of localization files.\n *\n * @param localizationFiles - The localization files to validate.\n * @returns The validated localization files.\n * @throws If any of the files are considered invalid.\n */\nexport function getValidatedLocalizationFiles(\n  localizationFiles: VirtualFile[],\n): VirtualFile<LocalizationFile>[] {\n  for (const file of localizationFiles) {\n    try {\n      file.result = create(parseJson(file.toString()), LocalizationFileStruct);\n    } catch (error) {\n      if (error instanceof StructError) {\n        throw new Error(\n          `Failed to validate localization file \"${file.path}\": ${error.message}.`,\n        );\n      }\n\n      if (error instanceof SyntaxError) {\n        throw new Error(\n          `Failed to parse localization file \"${file.path}\" as JSON.`,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  return localizationFiles as VirtualFile<LocalizationFile>[];\n}\n\n/**\n * Get the localization file for a given locale. If the locale is not found,\n * the English localization file will be returned.\n *\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localization file, or `undefined` if no localization file was\n * found.\n */\nexport function getLocalizationFile(\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = localizationFiles.find(\n    (localizationFile) => localizationFile.locale === locale,\n  );\n\n  if (!file) {\n    return localizationFiles.find(\n      (localizationFile) => localizationFile.locale === 'en',\n    );\n  }\n\n  return file;\n}\n\nexport const TRANSLATION_REGEX = /\\{\\{\\s?([a-zA-Z0-9-_\\s]+)\\s?\\}\\}/gu;\n\n/**\n * Translate a string using a localization file. This will replace all instances\n * of `{{key}}` with the localized version of `key`.\n *\n * @param value - The string to translate.\n * @param file - The localization file to use, or `undefined` if no localization\n * file was found.\n * @returns The translated string.\n * @throws If the string contains a key that is not present in the localization\n * file, or if no localization file was found.\n */\nexport function translate(value: string, file: LocalizationFile | undefined) {\n  const matches = value.matchAll(TRANSLATION_REGEX);\n  const array = Array.from(matches);\n\n  return array.reduce<string>((result, [match, key]) => {\n    if (!file) {\n      throw new Error(\n        `Failed to translate \"${value}\": No localization file found.`,\n      );\n    }\n\n    const translation = file.messages[key.trim()];\n    if (!translation) {\n      throw new Error(\n        `Failed to translate \"${value}\": No translation found for \"${key.trim()}\" in \"${\n          file.locale\n        }\" file.`,\n      );\n    }\n\n    return result.replace(match, translation.message);\n  }, value);\n}\n\n/**\n * Get the localized Snap manifest for a given locale. This will replace all\n * localized strings in the manifest with the localized version.\n *\n * @param snapManifest - The Snap manifest to localize.\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localized Snap manifest.\n */\nexport function getLocalizedSnapManifest(\n  snapManifest: SnapManifest,\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = getLocalizationFile(locale, localizationFiles);\n\n  return LOCALIZABLE_FIELDS.reduce((manifest, field) => {\n    const translation = translate(manifest[field], file);\n    return {\n      ...manifest,\n      [field]: translation,\n    };\n  }, snapManifest);\n}\n\n/**\n * Validate the localization files for a Snap manifest.\n *\n * @param snapManifest - The Snap manifest to validate.\n * @param localizationFiles - The localization files to validate.\n * @throws If the manifest cannot be localized.\n */\nexport function validateSnapManifestLocalizations(\n  snapManifest: SnapManifest,\n  localizationFiles: LocalizationFile[],\n) {\n  try {\n    // `translate` throws if the manifest cannot be localized, so we just attempt\n    // to translate the manifest using all localization files.\n    localizationFiles\n      .filter((file) => file.locale !== 'en')\n      .forEach((file) => {\n        getLocalizedSnapManifest(snapManifest, file.locale, localizationFiles);\n      });\n\n    // The manifest must be localizable in English.\n    getLocalizedSnapManifest(snapManifest, 'en', localizationFiles);\n  } catch (error) {\n    throw new Error(\n      `Failed to localize Snap manifest: ${getErrorMessage(error)}`,\n    );\n  }\n}\n"],"names":["getErrorMessage","create","object","optional","record","string","StructError","parseJson","LOCALIZABLE_FIELDS","LocalizationFileStruct","locale","messages","message","description","getValidatedLocalizationFiles","localizationFiles","file","result","toString","error","Error","path","SyntaxError","getLocalizationFile","find","localizationFile","TRANSLATION_REGEX","translate","value","matches","matchAll","array","Array","from","reduce","match","key","translation","trim","replace","getLocalizedSnapManifest","snapManifest","manifest","field","validateSnapManifestLocalizations","filter","forEach"],"mappings":"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"}